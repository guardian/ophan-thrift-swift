/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public enum RequestType : TEnum {
  case homefrontandgroups
  case frontandgroups
  case group
  case list
  case item
  case search

  public static func read(from proto: TProtocol) throws -> RequestType {
    let raw: Int32 = try proto.read()
    let new = RequestType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(RequestType.self)")
    }
  }

  public init() {
    self = .homefrontandgroups
  }

  public var rawValue: Int32 {
    switch self {
    case .homefrontandgroups: return 0
    case .frontandgroups: return 1
    case .group: return 2
    case .list: return 3
    case .item: return 4
    case .search: return 5
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .homefrontandgroups
    case 1: self = .frontandgroups
    case 2: self = .group
    case 3: self = .list
    case 4: self = .item
    case 5: self = .search
    default: return nil
    }
  }
}

public enum ConnectionType : TEnum {
  case wifi
  case wwan

  public static func read(from proto: TProtocol) throws -> ConnectionType {
    let raw: Int32 = try proto.read()
    let new = ConnectionType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ConnectionType.self)")
    }
  }

  public init() {
    self = .wifi
  }

  public var rawValue: Int32 {
    switch self {
    case .wifi: return 0
    case .wwan: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .wifi
    case 1: self = .wwan
    default: return nil
    }
  }
}

public enum BenchmarkType : TEnum {
  case taptoarticledisplay
  case launchtime

  public static func read(from proto: TProtocol) throws -> BenchmarkType {
    let raw: Int32 = try proto.read()
    let new = BenchmarkType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(BenchmarkType.self)")
    }
  }

  public init() {
    self = .taptoarticledisplay
  }

  public var rawValue: Int32 {
    switch self {
    case .taptoarticledisplay: return 0
    case .launchtime: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .taptoarticledisplay
    case 1: self = .launchtime
    default: return nil
    }
  }
}

public final class NetworkOperationData {

  /// The request type. This can be a single HTTP call or a succession of requests.
  public var requestType: RequestType

  /// The time to perform the operation, from the beginning of the request to processing the data.
  public var measuredTimeMs: Int64

  /// The type of connection used for performing the request.
  public var connectionType: ConnectionType?

  /// True if the request is considered successful.
  public var success: Bool


  public init(requestType: RequestType, measuredTimeMs: Int64, success: Bool) {
    self.requestType = requestType
    self.measuredTimeMs = measuredTimeMs
    self.success = success
  }

  public init(requestType: RequestType, measuredTimeMs: Int64, connectionType: ConnectionType?, success: Bool) {
    self.requestType = requestType
    self.measuredTimeMs = measuredTimeMs
    self.connectionType = connectionType
    self.success = success
  }

}

public final class BenchmarkData {

  /// An ID that can be used to identify a type benchmark.
  public var type: BenchmarkType

  /// The amount of time (in milliseconds) measured by this benchmark.
  public var measuredTimeMs: Int64


  public init(type: BenchmarkType, measuredTimeMs: Int64) {
    self.type = type
    self.measuredTimeMs = measuredTimeMs
  }

}


