/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: ComponentV2, rhs: ComponentV2) -> Bool {
  return
    (lhs.componentType == rhs.componentType) &&
    (lhs.id == rhs.id) &&
    (lhs.products == rhs.products) &&
    (lhs.campaignCode == rhs.campaignCode) &&
    (lhs.labels == rhs.labels)
}

extension ComponentV2 : CustomStringConvertible {

  public var description : String {
    var desc = "ComponentV2("
    desc += "componentType=\(String(describing: self.componentType)), "
    desc += "id=\(String(describing: self.id)), "
    desc += "products=\(String(describing: self.products)), "
    desc += "campaignCode=\(String(describing: self.campaignCode)), "
    desc += "labels=\(String(describing: self.labels))"
    return desc
  }

}

extension ComponentV2 : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(componentType)
    hasher.combine(id)
    hasher.combine(products)
    hasher.combine(campaignCode)
    hasher.combine(labels)
  }

}

extension ComponentV2 : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["componentType": 1, "id": 2, "products": 3, "campaignCode": 4, "labels": 5, ]
  }

  public static var structName: String { return "ComponentV2" }

  public static func read(from proto: TProtocol) throws -> ComponentV2 {
    _ = try proto.readStructBegin()
    var componentType: ComponentType!
    var id: String?
    var products: TSet<Product>!
    var campaignCode: String?
    var labels: TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             componentType = try ComponentType.read(from: proto)
        case (2, .string):           id = try String.read(from: proto)
        case (3, .set):             products = try TSet<Product>.read(from: proto)
        case (4, .string):           campaignCode = try String.read(from: proto)
        case (5, .set):             labels = try TSet<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(componentType, named: "componentType")
    try proto.validateValue(products, named: "products")
    try proto.validateValue(labels, named: "labels")

    return ComponentV2(componentType: componentType, id: id, products: products, campaignCode: campaignCode, labels: labels)
  }

}



public func ==(lhs: ComponentEvent, rhs: ComponentEvent) -> Bool {
  return
    (lhs.component == rhs.component) &&
    (lhs.action == rhs.action) &&
    (lhs.value == rhs.value) &&
    (lhs.id == rhs.id) &&
    (lhs.abTest == rhs.abTest) &&
    (lhs.targetingAbTest == rhs.targetingAbTest)
}

extension ComponentEvent : CustomStringConvertible {

  public var description : String {
    var desc = "ComponentEvent("
    desc += "component=\(String(describing: self.component)), "
    desc += "action=\(String(describing: self.action)), "
    desc += "value=\(String(describing: self.value)), "
    desc += "id=\(String(describing: self.id)), "
    desc += "abTest=\(String(describing: self.abTest)), "
    desc += "targetingAbTest=\(String(describing: self.targetingAbTest))"
    return desc
  }

}

extension ComponentEvent : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(component)
    hasher.combine(action)
    hasher.combine(value)
    hasher.combine(id)
    hasher.combine(abTest)
    hasher.combine(targetingAbTest)
  }

}

extension ComponentEvent : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["component": 1, "action": 2, "value": 3, "id": 4, "abTest": 5, "targetingAbTest": 6, ]
  }

  public static var structName: String { return "ComponentEvent" }

  public static func read(from proto: TProtocol) throws -> ComponentEvent {
    _ = try proto.readStructBegin()
    var component: ComponentV2!
    var action: Action!
    var value: String?
    var id: String?
    var abTest: AbTest?
    var targetingAbTest: AbTest?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           component = try ComponentV2.read(from: proto)
        case (2, .i32):             action = try Action.read(from: proto)
        case (3, .string):           value = try String.read(from: proto)
        case (4, .string):           id = try String.read(from: proto)
        case (5, .struct):           abTest = try AbTest.read(from: proto)
        case (6, .struct):           targetingAbTest = try AbTest.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(component, named: "component")
    try proto.validateValue(action, named: "action")

    return ComponentEvent(component: component, action: action, value: value, id: id, abTest: abTest, targetingAbTest: targetingAbTest)
  }

}



