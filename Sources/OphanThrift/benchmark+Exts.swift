/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: NetworkOperationData, rhs: NetworkOperationData) -> Bool {
  return
    (lhs.requestType == rhs.requestType) &&
    (lhs.measuredTimeMs == rhs.measuredTimeMs) &&
    (lhs.connectionType == rhs.connectionType) &&
    (lhs.success == rhs.success)
}

extension NetworkOperationData : CustomStringConvertible {

  public var description : String {
    var desc = "NetworkOperationData("
    desc += "requestType=\(String(describing: self.requestType)), "
    desc += "measuredTimeMs=\(String(describing: self.measuredTimeMs)), "
    desc += "connectionType=\(String(describing: self.connectionType)), "
    desc += "success=\(String(describing: self.success))"
    return desc
  }

}

extension NetworkOperationData : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(requestType)
    hasher.combine(measuredTimeMs)
    hasher.combine(connectionType)
    hasher.combine(success)
  }

}

extension NetworkOperationData : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["requestType": 1, "measuredTimeMs": 2, "connectionType": 3, "success": 4, ]
  }

  public static var structName: String { return "NetworkOperationData" }

  public static func read(from proto: TProtocol) throws -> NetworkOperationData {
    _ = try proto.readStructBegin()
    var requestType: RequestType!
    var measuredTimeMs: Int64!
    var connectionType: ConnectionType?
    var success: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             requestType = try RequestType.read(from: proto)
        case (2, .i64):             measuredTimeMs = try Int64.read(from: proto)
        case (3, .i32):             connectionType = try ConnectionType.read(from: proto)
        case (4, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(requestType, named: "requestType")
    try proto.validateValue(measuredTimeMs, named: "measuredTimeMs")
    try proto.validateValue(success, named: "success")

    return NetworkOperationData(requestType: requestType, measuredTimeMs: measuredTimeMs, connectionType: connectionType, success: success)
  }

}



public func ==(lhs: BenchmarkData, rhs: BenchmarkData) -> Bool {
  return
    (lhs.type == rhs.type) &&
    (lhs.measuredTimeMs == rhs.measuredTimeMs)
}

extension BenchmarkData : CustomStringConvertible {

  public var description : String {
    var desc = "BenchmarkData("
    desc += "type=\(String(describing: self.type)), "
    desc += "measuredTimeMs=\(String(describing: self.measuredTimeMs))"
    return desc
  }

}

extension BenchmarkData : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(type)
    hasher.combine(measuredTimeMs)
  }

}

extension BenchmarkData : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["type": 1, "measuredTimeMs": 2, ]
  }

  public static var structName: String { return "BenchmarkData" }

  public static func read(from proto: TProtocol) throws -> BenchmarkData {
    _ = try proto.readStructBegin()
    var type: BenchmarkType!
    var measuredTimeMs: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             type = try BenchmarkType.read(from: proto)
        case (2, .i64):             measuredTimeMs = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(type, named: "type")
    try proto.validateValue(measuredTimeMs, named: "measuredTimeMs")

    return BenchmarkData(type: type, measuredTimeMs: measuredTimeMs)
  }

}



