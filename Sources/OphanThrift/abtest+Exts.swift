/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: AbTest, rhs: AbTest) -> Bool {
  return
    (lhs.name == rhs.name) &&
    (lhs.variant == rhs.variant) &&
    (lhs.complete == rhs.complete) &&
    (lhs.campaignCodes == rhs.campaignCodes)
}

extension AbTest : CustomStringConvertible {

  public var description : String {
    var desc = "AbTest("
    desc += "name=\(String(describing: self.name)), "
    desc += "variant=\(String(describing: self.variant)), "
    desc += "complete=\(String(describing: self.complete)), "
    desc += "campaignCodes=\(String(describing: self.campaignCodes))"
    return desc
  }

}

extension AbTest : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(name)
    hasher.combine(variant)
    hasher.combine(complete)
    hasher.combine(campaignCodes)
  }

}

extension AbTest : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["name": 1, "variant": 2, "complete": 3, "campaignCodes": 4, ]
  }

  public static var structName: String { return "AbTest" }

  public static func read(from proto: TProtocol) throws -> AbTest {
    _ = try proto.readStructBegin()
    var name: String!
    var variant: String!
    var complete: Bool?
    var campaignCodes: TSet<String>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           name = try String.read(from: proto)
        case (2, .string):           variant = try String.read(from: proto)
        case (3, .bool):            complete = try Bool.read(from: proto)
        case (4, .set):             campaignCodes = try TSet<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")
    try proto.validateValue(variant, named: "variant")

    return AbTest(name: name, variant: variant, complete: complete, campaignCodes: campaignCodes)
  }

}



public func ==(lhs: AbTestInfo, rhs: AbTestInfo) -> Bool {
  return
    (lhs.tests == rhs.tests)
}

extension AbTestInfo : CustomStringConvertible {

  public var description : String {
    var desc = "AbTestInfo("
    desc += "tests=\(String(describing: self.tests))"
    return desc
  }

}

extension AbTestInfo : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(tests)
  }

}

extension AbTestInfo : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["tests": 1, ]
  }

  public static var structName: String { return "AbTestInfo" }

  public static func read(from proto: TProtocol) throws -> AbTestInfo {
    _ = try proto.readStructBegin()
    var tests: TSet<AbTest>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .set):             tests = try TSet<AbTest>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(tests, named: "tests")

    return AbTestInfo(tests: tests)
  }

}



